בס"ד

ID: 212051007 Mail: mayrozen45@gmail.com

מטלה 3 - תכנות מערכות 2:

במטלה זו הושם דגש על מחלקות וירושה. במהלך קובץ זה אפרט על נקודה זו וכן על הסיבות לצורות המימוש השונות אותן בחרתי במהלך מטלה זו.

  -תחילה אפרט על תפקידה של כל מחלקה:-

  

catan.hpp: המחלקה Catan מייצגת את משחק ה-Catan, כוללת את ניהול השחקנים, הלוח, והפעולות הבסיסיות של המשחק כמו אתחול המשאבים, בחירת שחקן התחלה, ניהול הזוכה והדפסת מידע על המשחק.

board.hpp: מגדיר את המחלקה Board שמייצגת את לוח המשחק, כולל פונקציות כגון התחלה, הדפסה כמטריצה וקבלת אריחים.

Tile.cpp: מממש את המחלקה Tile המייצגת אריח בלוח המשחק, כולל סוג משאב וערך.

DevelopmentCard.hpp: מחלקה אבסטרקטית המגדירה את הממשק לכל כרטיס פיתוח. כוללת את הפונקציות הקבועות getType() ו-getCardName() המחזירות את סוג הכרטיס ושם הכרטיס בהתאמה.

MonopolyCard, BuildingRoadsCard, YearOfAbundanceCard, KnightCard, VictoryPointCard: מחלקות שונות היורשות מ-DevelopmentCard ומממשות את הפונקציות getType() ו-getCardName() בהתאם לסוג הכרטיס הספציפי שלהן.
structure.cpp: המחלקה מגדירה סוגים שונים של מבנים במשחק ומגדירה את המשאבים הנדרשים לבניית כל מבנה.

Player.hpp: המחלקה Player מייצגת שחקן במשחק (Catan), ומכילה את כל הנתונים והפעולות הקשורות לשחקן כגון משאבים, מבנים (כמו דרכים, התנחלויות וערים), קלפי פיתוח, ניהול התור, ופעולות שונות כגון גלגול הקוביות, סחר עם שחקנים אחרים, קניית קלפי פיתוח, והשקפת ניקוד.

    -מחלקת catan-
מחלקה זו מבטאת את המשחק עצמו. זהו משתנה סינגלטוני שבעת קריאה לבנייתו נכנסים שלושה שחקנים מסוג player למשחק וכן נבנה הלוח. כמו כן, עבור כל שחקן נכנסים משאבים התחלתיים איתם יוכל לבנות 2 דרכים ו - 2 יישובים לפי כללי המשחק.

    -מימוש הלוח בפרויקט: board, Tile, structure-

את הלוח בניתי על ידי tiles כאשר כל אחד מורכב ממספר ומשאב אותו הוא מחזיר. הלוח כולו מורכב סה"כ מ - 34 tiles כאשר השורה העליונה והתחתונה מבטאות ים וכן גם צדדי הלוח.
בנוסף, עבור כל משאב (tile), יש שני ווקטורים - צלעות וקודקודים. כל ווקטור מכיל מצביעים למבנים (דרכים, יישובים וערים) כאשר המבנים עצמם נמצאים במחלקת player עבור כל שחקן. זאת על מנת שנהיה בעלי יכולת לגשת דרך כל משאב למבנים ואף לשחקן שהוא בעל המבנים.
יתר על כן, עבור כל tile קיים גם ווקטור המכיל "שכנים". כלומר, דרך כל משאב ניתן לראות מי הם המשאבים שסביבו. זאת על מנת למנוע כפילויות בדרכים, יישובים וערים ולראות דרך כל משאב את אותו יישוב (לדוגמה) כאשר המצביע אליו נמצא בכול ווקטור קודקודים של המשאבים הרלוונטים.
כמו כן, דרך מימוש זאת עוזרת לנו להבין עבור כל יישוב ועיר האם ניתן לבנות אותם (בהתאם לכללי המשחק) וכן אילו משאבים הם יחזירו בעת הטלת הקוביות הרלוונטית.
נשים לב לירושה הנמצאת במחלקת structur:
המחלקה הינה אבסטרקטית (הרי אין משמעות למבנה באופן כללי, אלא רק באופן ישיר - דרך, יישוב או עיר). המחלקה מכילה משתנה - שם המבנה (road, structure, city) וכן וקטור המכיל את המשאבים איתם ניתן לבנות את אותו המבנה.

    -מימוש שחקני המשחק: player-

  שחקן נבנה על ידי השמת שם לשחקן.
מעבר לכך, כל שחקן מכיל כמה ערכים:

    vector<ReturnRes> returnRes; // All the resources the player has
כל שחקן מכיל ווקטור המכיל את כל קלפי המשאבים שברשותו.

    vector<Structure> roads;
וקטור המכיל את כל הדרכים שברשותו כאשר אלו האובייקטים עצמם (כפי שציינתי קודם - בקלפי הלוח עצמם יש גישה לאובייטים אלו על ידי ווקטור המכיל פוינטרים למבנים אלו).

    vector<Structure> settlements;
וקטור המכיל את כל היישובים שברשותו של השחקן.

    vector<Structure> cities;
כל הערים שברשותו של השחקן.

    vector<DevelopmentCard*> DevelopmentCards;
כל קלפי הפיתוח שברשותו של השחקן. על מנת להפעיל את קלפי הפיתוח על השחקן להשתמש בפונקציית useCard() הנמצאת במחלקת של קלפי הפיתוח. במהלך הפעלת הקלפים מתבצעות כלל הבדיקות הנצרכות כמו השמת משאבים או מבנים חדשים לאותו שחקן וכן נקודות ניצחון. זאת בהתאם למה שמקנה אותו קלף פיתוח שהשחקן הפעיל.

    int sumOfKnights;
כמות האבירים שיש לשחקן. זאת על מנת לוודא למי מבין השחקנים יש את "הצבא הגדול ביותר" - תואר המקנה 2 נקודות ניצחון לשחקן המחזיק בו.

    int sumPoints;
סכום נקודות הניצחון עבור אותו שחקן (שחקן המגיע ל - 10 נקודות מנצח את המשחק).

    bool turn = true; // When it is the player's turn -> true
משתנה בוליאני ש"נדלק" בעת תורו של השחקן ו"נכבה" בעת סיום תורו.

    - מימוש קלפי הפיתוח: DevelopmentCard: - 
בדומה למחלקת structure, גם את מחלקה זו מימשתי באופן אבסטרקטי. מחלקה זו מכילה בנאי עבור כל כרטיס, סוג הכרטיס (CardType getType() const override), ושמו כמחרוזת (string getCardName() const override).





כמו כן, למטלה זו קיימים טסטים ומימושים רבים לכלל המחלקות אשר מפורטים על ידי הערות בקוד עצמו.
